# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Construct the interval tree
#' @param c Vector of chromosomes (as integers)
#' @param s Vector of start positions
#' @param e Vector of end positions
#' @param tree GenomicIntervalTreeMap to fill (see https://github.com/walaj/SeqLib)
#' @noRd
NULL

#' Calculate if a range overlaps against an interval tree
#' @param tree Interval tree (map) to query against
#' @param c Query chromosome
#' @param s Query start
#' @param e Query end
#' @param index Position of the query range in the query set
#' @param query Will store the index of the query range
#' @param subject Will store the index of the subject range
#' @param chr Will store the chromosome of the output overlap range
#' @param start Will store the start of the output overlap range
#' @param end Will store the end of the output overlap range
#' @noRd
NULL

#' Check if a set of ranges is sorted
#'
#' Will throw and error if seqnames are not relatively sorted (but does not check
#' if absolutely sorted relative to ordering e.g. alphanumeric)
#' or will throw error if start position not sorted or will throw error if
#' range has negative (end < start) width.
#' SORTING ACTUALLY NOT REQUIRED
#' @param c Seqnames
#' @param s start positions
#' @param e end positions
#' @noRd
NULL

#' Perform the overlaps using an interval tree
#' @param df1 query data.table / data.frame with fields: seqnames, start, end
#' @param df2 subject data.table / data.frame with fields: seqnames, start, end
#' @param verbose Print more
#' @param index_only Only return the index values (saves memory)
#' @return data.frame with ranges (seqnames, start, end) and query.id and subject.id
#' @noRd
cppoverlaps <- function(df1, df2, verbose, index_only) {
    .Call('_roverlaps_cppoverlaps', PACKAGE = 'roverlaps', df1, df2, verbose, index_only)
}

#' Perform the ragged difference
#' @param query Numeric vector to query 
#' @param subject Subject to query
#' @param max Return the max difference instead of min
#' @param sign If 0, consider values where q > s and s > q, if 1 only consider values where q >= s, if -1 only consider values where s >= q
#' @return Numeric vector of length same as query, of differences between query and subject
#' @noRd
cppraggeddiff <- function(query, subject, max, sign = 0L) {
    .Call('_roverlaps_cppraggeddiff', PACKAGE = 'roverlaps', query, subject, max, sign)
}

#' Perform the ragged difference between a vector and intervals
#' @param query Numeric vector to query 
#' @param subject_start Subject to query (start coordinates)
#' @param subject_end Subject to query (end coordinates)
#' @param max Return the max difference instead of min
#' @param sign If 0, consider values where q > s and s > q, if 1 only consider values where q >= s, if -1 only consider values where s >= q
#' @return Numeric vector of length same as query, of differences between query and subject
#' @noRd
cppraggeddiffinterval <- function(query, subject_start, subject_end, max, sign = 0L) {
    .Call('_roverlaps_cppraggeddiffinterval', PACKAGE = 'roverlaps', query, subject_start, subject_end, max, sign)
}

